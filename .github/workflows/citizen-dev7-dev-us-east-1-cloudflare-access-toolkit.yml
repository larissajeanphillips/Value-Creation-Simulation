---
  name: "McKinsey ID Access Setup"
  
  # ================================================================
  # Purpose: Workflow that runs Cloudflare Access validation/apply
  #          using McK-Internal/cloudflare-ztna-toolkit.
  #
  # Triggers:
  #   - Manual workflow dispatch only
  #
  # Required Secrets:
  #   - GA_PAT: Org secret for cross-repo checkout of the toolkit
  #   - CLOUDFLARE_API_TOKEN: Cloudflare API token (for validate/apply)
  #   - MID_CLIENT_SECRET: McKinsey ID Client Secret
  #
  # Dependencies:
  #   - McK-Internal/cloudflare-ztna-toolkit (default ref: feat/cloudflare-access)
  # ================================================================
  
  run-name: >-
    McKinsey ID Access Setup
  
  on:
    workflow_dispatch:
      inputs:
        mid_client_id:
          description: "McKinsey ID Client ID"
          required: true
          type: string
        mid_group_name:
          description: "McKinsey ID Group Name"
          required: true
          type: string
  
  permissions: {}
  
  concurrency:
    group: >-
      poc-cloudflare-access-toolkit-${{ github.workflow }}
    cancel-in-progress: false
  
  jobs:
    setup:
      name: Setup and Apply Cloudflare Access Configuration
      runs-on: gh-larger-linux-mini
      timeout-minutes: 45
      permissions:
        contents: read
      steps:
        - name: Checkout Cloudflare Access/ZTNA Toolkit
          uses: actions/checkout@v6
          with:
            repository: McK-Internal/cloudflare-ztna-toolkit
            ref: "main"
            path: cloudflare-ztna-toolkit
            # Cross-repo checkout requires a token that can read the toolkit repo.
            token: ${{ secrets.GA_PAT }}
  
        - name: Set up Python
          uses: actions/setup-python@v5
          with:
            python-version: "3.13"
            cache: pip
            cache-dependency-path: cloudflare-ztna-toolkit/requirements.txt
  
        - name: Install dependencies
          working-directory: cloudflare-ztna-toolkit
          run: |
            python -m pip install --upgrade pip
            python -m pip install -r requirements.txt
  
        - name: Create payload generator script
          working-directory: cloudflare-ztna-toolkit
          env:
            MID_CLIENT_ID: ${{ inputs.mid_client_id }}
            MID_CLIENT_SECRET: ${{ secrets.MID_CLIENT_SECRET }}
            MID_GROUP_NAME: ${{ inputs.mid_group_name }}
            APP_NAME: "citizen-dev7"
          run: |
            cat > generate_payload.py << 'PYTHON_SCRIPT'
            #!/usr/bin/env python3
            import json
            import os
            import sys
            
            try:
                mid_client_id = os.environ['MID_CLIENT_ID']
                mid_client_secret = os.environ['MID_CLIENT_SECRET']
                mid_group_name = os.environ['MID_GROUP_NAME']
                app_name = os.environ['APP_NAME']
            
                identity_provider_name = f"{app_name}-idp"
                policy_name = f"{app_name}-policy"
                app_config_name = f"{app_name}-app"
                domain = f"{app_name}.sbx.apps.mckinsey.com"
            
                payload = {
                    "app_name": domain,
                    "identity_providers": [
                        {
                            "name": identity_provider_name,
                            "type": "oidc",
                            "config": {
                                "client_id": mid_client_id,
                                "client_secret": mid_client_secret,
                                "auth_url": "https://auth.mckinsey.id/auth/realms/r/protocol/openid-connect/auth",
                                "token_url": "https://auth.mckinsey.id/auth/realms/r/protocol/openid-connect/token",
                                "certs_url": "https://auth.mckinsey.id/auth/realms/r/protocol/openid-connect/certs",
                                "claims": ["email", "groups", "given_name", "family_name", "acr"],
                                "scopes": ["openid", "email", "profile"],
                                "pkce_enabled": False
                            }
                        }
                    ],
                    "policies": [
                        {
                            "name": policy_name,
                            "decision": "allow",
                            "precedence": 100,
                            "include": [
                                {
                                    "oidc": {
                                        "identity_provider_name": identity_provider_name,
                                        "name": "groups",
                                        "value": mid_group_name
                                    }
                                }
                            ]
                        }
                    ],
                    "apps": [
                        {
                            "name": app_config_name,
                            "type": "self_hosted",
                            "domain": domain,
                            "policies": [policy_name],
                            "allowed_idps": [identity_provider_name]
                        }
                    ]
                }
                # Print payload and flush immediately
                payload_json = json.dumps(payload)
                print(payload_json, flush=True)
                sys.stdout.flush()
            except KeyError as e:
                print(f"Error: Missing environment variable: {e}", file=sys.stderr)
                sys.exit(1)
            except Exception as e:
                print(f"Error: {e}", file=sys.stderr)
                sys.exit(1)
            PYTHON_SCRIPT
            
            # Verify script was created correctly
            if [ ! -f generate_payload.py ]; then
              echo "Error: Script file was not created" >&2
              exit 1
            fi
            echo "Script file created successfully, size: $(wc -c < generate_payload.py) bytes" >&2
            echo "First 10 lines of script:" >&2
            head -10 generate_payload.py >&2
  
        - name: Schema-only validation (no Cloudflare API)
          working-directory: cloudflare-ztna-toolkit
          env:
            MID_CLIENT_ID: ${{ inputs.mid_client_id }}
            MID_CLIENT_SECRET: ${{ secrets.MID_CLIENT_SECRET }}
            MID_GROUP_NAME: ${{ inputs.mid_group_name }}
            APP_NAME: "citizen-dev7"
          run: |
            set -euo pipefail
            # Verify script exists
            if [ ! -f generate_payload.py ]; then
              echo "Error: generate_payload.py not found" >&2
              ls -la >&2
              exit 1
            fi
            
            # Generate payload in memory using reusable script
            # Run script with unbuffered output and capture stdout and stderr separately
            echo "Running payload generation script..." >&2
            echo "Current directory: $(pwd)" >&2
            echo "Script file exists: $([ -f generate_payload.py ] && echo 'yes' || echo 'no')" >&2
            
            # Use a temporary file for stderr to avoid issues with command substitution
            TEMP_STDERR=$(mktemp)
            if ! SCRIPT_STDOUT=$(python3 -u generate_payload.py 2>"$TEMP_STDERR"); then
              SCRIPT_EXIT=$?
              SCRIPT_STDERR=$(cat "$TEMP_STDERR" 2>/dev/null || echo "")
              rm -f "$TEMP_STDERR"
              echo "Error: Script execution failed with exit code $SCRIPT_EXIT" >&2
              echo "Stderr output:" >&2
              echo "$SCRIPT_STDERR" >&2
              exit 1
            fi
            SCRIPT_EXIT=$?
            SCRIPT_STDERR=$(cat "$TEMP_STDERR" 2>/dev/null || echo "")
            rm -f "$TEMP_STDERR"
            
            echo "Script exit code: $SCRIPT_EXIT" >&2
            echo "Script stdout length: ${#SCRIPT_STDOUT}" >&2
            echo "Script stderr length: ${#SCRIPT_STDERR}" >&2
            if [ -n "$SCRIPT_STDERR" ]; then
              echo "Script stderr content: $SCRIPT_STDERR" >&2
            fi
            
            # Check exit code
            if [ $SCRIPT_EXIT -ne 0 ]; then
              echo "Error: Script execution failed with exit code $SCRIPT_EXIT" >&2
              echo "Stderr output:" >&2
              echo "$SCRIPT_STDERR" >&2
              exit 1
            fi
            
            # Check if stderr has errors
            if [ -n "$SCRIPT_STDERR" ]; then
              echo "Warning: Script produced stderr output:" >&2
              echo "$SCRIPT_STDERR" >&2
              # If stderr contains "Error:", treat as failure
              if echo "$SCRIPT_STDERR" | grep -q "Error:"; then
                echo "Error: Script reported an error" >&2
                exit 1
              fi
            fi
            
            PAYLOAD_JSON="$SCRIPT_STDOUT"
            
            # Validate payload is not empty
            echo "PAYLOAD_JSON length after assignment: ${#PAYLOAD_JSON}" >&2
            if [ -z "${PAYLOAD_JSON:-}" ]; then
              echo "Error: PAYLOAD_JSON is empty after script execution" >&2
              echo "Script stdout length: ${#SCRIPT_STDOUT}" >&2
              echo "Script stderr:" >&2
              echo "$SCRIPT_STDERR" >&2
              echo "Environment variables:" >&2
              env | grep -E "(MID_CLIENT|MID_GROUP|APP_NAME)" >&2 || echo "No matching env vars found" >&2
              echo "Testing script directly:" >&2
              python3 generate_payload.py >&2
              exit 1
            fi
            
            # Validate schema using environment variable (no file written)
            echo "About to validate schema, PAYLOAD_JSON length: ${#PAYLOAD_JSON}" >&2
            PAYLOAD_JSON="$PAYLOAD_JSON" PYTHONPATH=src python - <<'PY'
            import json
            import os
  
            import jsonschema
  
            from cloudflare_ztna_toolkit_v2.access_schema import (
              ACCESS_CONFIG_SCHEMA,
            )
  
            payload_json = os.environ['PAYLOAD_JSON']
            data = json.loads(payload_json)
            jsonschema.validate(instance=data, schema=ACCESS_CONFIG_SCHEMA)
            print("Schema validation OK")
            PY
  
        - name: Secrets present?
          id: secrets_check
          env:
            CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          run: |
            set -euo pipefail
            if [ -z "${CLOUDFLARE_API_TOKEN:-}" ]; then
              echo "Missing secret: CLOUDFLARE_API_TOKEN" >&2
              echo "have_secrets=false" >> "$GITHUB_OUTPUT"
            else
              echo "have_secrets=true" >> "$GITHUB_OUTPUT"
            fi
  
        - name: Validate (cloudflare-access)
          if: ${{ steps.secrets_check.outputs.have_secrets == 'true' }}
          working-directory: cloudflare-ztna-toolkit
          env:
            CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
            MID_CLIENT_ID: ${{ inputs.mid_client_id }}
            MID_CLIENT_SECRET: ${{ secrets.MID_CLIENT_SECRET }}
            MID_GROUP_NAME: ${{ inputs.mid_group_name }}
            APP_NAME: "citizen-dev7"
            MIDV2_OIDC_CLIENT_SECRET: ${{ secrets.MID_CLIENT_SECRET }}
            MIDV2_SBX_ZTNA_GROUP: ${{ inputs.mid_group_name }}
          run: |
            set -euo pipefail
            # Verify script exists
            if [ ! -f generate_payload.py ]; then
              echo "Error: generate_payload.py not found" >&2
              exit 1
            fi
            
            # Generate payload in memory using reusable script
            SCRIPT_STDOUT=$(python3 generate_payload.py 2>/tmp/script_stderr.log)
            SCRIPT_EXIT=$?
            SCRIPT_STDERR=$(cat /tmp/script_stderr.log 2>/dev/null || echo "")
            rm -f /tmp/script_stderr.log
            
            if [ $SCRIPT_EXIT -ne 0 ] || [ -n "$SCRIPT_STDERR" ] && echo "$SCRIPT_STDERR" | grep -q "Error:"; then
              echo "Error: Script execution failed" >&2
              echo "Exit code: $SCRIPT_EXIT" >&2
              echo "Stderr: $SCRIPT_STDERR" >&2
              exit 1
            fi
            
            PAYLOAD_JSON="$SCRIPT_STDOUT"
            
            if [ -z "${PAYLOAD_JSON:-}" ]; then
              echo "Error: PAYLOAD_JSON is empty" >&2
              exit 1
            fi
            
            # Use process substitution to pass payload without writing to file
            PYTHONPATH=src python -m cloudflare_ztna_toolkit_v2.main validate <(printf '%s' "$PAYLOAD_JSON")
  
        - name: Apply Cloudflare Access Configuration
          if: ${{ steps.secrets_check.outputs.have_secrets == 'true' }}
          working-directory: cloudflare-ztna-toolkit
          env:
            CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
            MID_CLIENT_ID: ${{ inputs.mid_client_id }}
            MID_CLIENT_SECRET: ${{ secrets.MID_CLIENT_SECRET }}
            MID_GROUP_NAME: ${{ inputs.mid_group_name }}
            APP_NAME: "citizen-dev7"
            MIDV2_OIDC_CLIENT_SECRET: ${{ secrets.MID_CLIENT_SECRET }}
            MIDV2_SBX_ZTNA_GROUP: ${{ inputs.mid_group_name }}
          run: |
            set -euo pipefail
            # Verify script exists
            if [ ! -f generate_payload.py ]; then
              echo "Error: generate_payload.py not found" >&2
              exit 1
            fi
            
            # Generate payload in memory using reusable script
            SCRIPT_STDOUT=$(python3 generate_payload.py 2>/tmp/script_stderr.log)
            SCRIPT_EXIT=$?
            SCRIPT_STDERR=$(cat /tmp/script_stderr.log 2>/dev/null || echo "")
            rm -f /tmp/script_stderr.log
            
            if [ $SCRIPT_EXIT -ne 0 ] || [ -n "$SCRIPT_STDERR" ] && echo "$SCRIPT_STDERR" | grep -q "Error:"; then
              echo "Error: Script execution failed" >&2
              echo "Exit code: $SCRIPT_EXIT" >&2
              echo "Stderr: $SCRIPT_STDERR" >&2
              exit 1
            fi
            
            PAYLOAD_JSON="$SCRIPT_STDOUT"
            
            if [ -z "${PAYLOAD_JSON:-}" ]; then
              echo "Error: PAYLOAD_JSON is empty" >&2
              exit 1
            fi
            
            # Validate it's valid JSON (redirect stderr to avoid exposing payload in error messages)
            printf '%s' "$PAYLOAD_JSON" | python3 -m json.tool > /dev/null 2>&1 || { echo "Error: Generated payload is not valid JSON" >&2; exit 1; }
            
            # Use process substitution to pass payload without writing to file
            PYTHONPATH=src python -m cloudflare_ztna_toolkit_v2.main apply <(printf '%s' "$PAYLOAD_JSON")
